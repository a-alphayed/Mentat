# MCP Orchestration Configuration
# Intelligent server selection, coordination, and load balancing patterns
# Enables smart MCP server orchestration based on context and performance

# Metadata
version: "1.0.0"
last_updated: "2025-01-06"
description: "MCP server orchestration intelligence patterns"

# Server Selection Intelligence
server_selection:
  decision_tree:
    # UI/Design Operations
    - name: "ui_component_operations"
      conditions:
        keywords: ["component", "ui", "design", "frontend", "jsx", "tsx", "css"]
        OR:
          - operation_type: ["build", "implement", "design"]
          - file_extensions: [".jsx", ".tsx", ".vue", ".css", ".scss"]
      primary_server: "magic"
      support_servers: ["context7"]
      coordination_mode: "parallel"
      confidence: 0.9
      
    # Analysis and Architecture Operations  
    - name: "complex_analysis"
      conditions:
        AND:
          - complexity_score: ">0.7"
          - operation_type: ["analyze", "review", "debug", "troubleshoot"]
        OR:
          - file_count: ">10"
          - keywords: ["architecture", "system", "complex"]
      primary_server: "sequential"
      support_servers: ["context7", "serena"]
      coordination_mode: "sequential"
      confidence: 0.85
      
    # Code Refactoring and Transformation
    - name: "code_refactoring"
      conditions:
        AND:
          - operation_type: ["refactor", "transform", "modify"]
        OR:
          - file_count: ">5"
          - complexity_score: ">0.5"
          - keywords: ["refactor", "cleanup", "optimize"]
      primary_server: "serena"
      support_servers: ["morphllm", "sequential"]
      coordination_mode: "hybrid"
      confidence: 0.8
      
    # Documentation and Learning
    - name: "documentation_operations"
      conditions:
        keywords: ["document", "explain", "guide", "tutorial", "learn"]
        OR:
          - operation_type: ["document", "explain"]
          - file_extensions: [".md", ".rst", ".txt"]
      primary_server: "context7"
      support_servers: ["sequential"]
      coordination_mode: "sequential"  
      confidence: 0.85
      
    # Testing and Validation
    - name: "testing_operations"
      conditions:
        keywords: ["test", "validate", "check", "verify", "e2e"]
        OR:
          - operation_type: ["test", "validate"]
          - file_patterns: ["*test*", "*spec*", "*e2e*"]
      primary_server: "playwright"
      support_servers: ["sequential", "magic"]
      coordination_mode: "parallel"
      confidence: 0.8
      
    # Fast Edits and Transformations
    - name: "fast_edits"
      conditions:
        AND:
          - complexity_score: "<0.4"
          - file_count: "<5"
        operation_type: ["edit", "modify", "fix", "update"]
      primary_server: "morphllm"
      support_servers: ["serena"]
      coordination_mode: "fallback"
      confidence: 0.7
      
  # Fallback Strategy
  fallback_chain:
    default_primary: "sequential"
    fallback_sequence: ["context7", "serena", "morphllm", "magic", "playwright"]
    fallback_threshold: 3.0  # seconds timeout
    
# Load Balancing Intelligence
load_balancing:
  health_monitoring:
    # Server health check configuration
    check_interval: 30  # seconds
    timeout: 5         # seconds
    retry_count: 3
    
    health_metrics:
      - response_time
      - error_rate  
      - request_queue_size
      - availability_percentage
      
  performance_thresholds:
    # Performance-based routing thresholds
    response_time:
      excellent: 500    # ms
      good: 1000       # ms  
      warning: 2000    # ms
      critical: 5000   # ms
      
    error_rate:
      excellent: 0.01  # 1%
      good: 0.03      # 3%
      warning: 0.05   # 5%
      critical: 0.15  # 15%
      
    queue_size:
      excellent: 0
      good: 2
      warning: 5
      critical: 10
      
  routing_strategies:
    # Load balancing algorithms
    primary_strategy: "weighted_performance"
    strategies:
      round_robin:
        description: "Distribute requests evenly across healthy servers"
        weight_factor: "equal"
        
      weighted_performance:
        description: "Route based on server performance metrics"
        weight_factors:
          response_time: 0.4
          error_rate: 0.3
          availability: 0.3
          
      least_connections:
        description: "Route to server with fewest active connections"
        connection_tracking: true
        
      performance_based:
        description: "Route to best-performing server"
        performance_window: 300  # seconds

# Cross-Server Coordination
coordination_patterns:
  sequential_coordination:
    # When servers work in sequence
    patterns:
      - name: "analysis_then_implementation"
        sequence: ["sequential", "morphllm"]
        trigger: {operation: "implement", analysis_required: true}
        
      - name: "research_then_build" 
        sequence: ["context7", "magic"]
        trigger: {operation: "build", research_required: true}
        
      - name: "plan_then_execute"
        sequence: ["sequential", "serena", "morphllm"]
        trigger: {complexity: ">0.7", operation: "refactor"}
        
  parallel_coordination:
    # When servers work simultaneously
    patterns:
      - name: "ui_with_docs"
        parallel: ["magic", "context7"]
        trigger: {operation: "build", component_type: "ui"}
        synchronization: "merge_results"
        
      - name: "test_with_validation"
        parallel: ["playwright", "sequential"]
        trigger: {operation: "test", validation_required: true}
        synchronization: "wait_all"
        
  hybrid_coordination:
    # Mixed coordination patterns
    patterns:
      - name: "comprehensive_refactoring"
        phases:
          - phase: 1
            servers: ["sequential"]  # Analysis
            wait_for_completion: true
          - phase: 2  
            servers: ["serena", "morphllm"]  # Parallel execution
            synchronization: "coordinate_changes"

# Dynamic Server Capabilities
capability_assessment:
  dynamic_capabilities:
    # Assess server capabilities in real-time
    assessment_interval: 60  # seconds
    capability_metrics:
      - processing_speed
      - accuracy_score
      - specialization_match
      - current_load
      
  capability_mapping:
    # Map operations to server capabilities
    magic:
      specializations: ["ui", "components", "design", "frontend"]
      performance_profile: "medium_latency_high_quality"
      optimal_load: 3
      
    sequential:
      specializations: ["analysis", "debugging", "complex_reasoning"]
      performance_profile: "high_latency_high_quality"
      optimal_load: 2
      
    context7:
      specializations: ["documentation", "learning", "research"]
      performance_profile: "low_latency_medium_quality"
      optimal_load: 5
      
    serena:
      specializations: ["refactoring", "large_codebases", "semantic_analysis"]
      performance_profile: "medium_latency_high_precision"
      optimal_load: 3
      
    morphllm:
      specializations: ["fast_edits", "transformations", "pattern_matching"]
      performance_profile: "low_latency_medium_quality"
      optimal_load: 4
      
    playwright:
      specializations: ["testing", "validation", "browser_automation"]
      performance_profile: "high_latency_specialized"
      optimal_load: 2

# Error Handling and Recovery
error_handling:
  retry_strategies:
    # Server error retry patterns
    exponential_backoff:
      initial_delay: 1    # seconds
      max_delay: 60      # seconds  
      multiplier: 2
      max_retries: 3
      
  graceful_degradation:
    # Fallback when servers fail
    degradation_levels:
      - level: 1
        strategy: "use_secondary_server"
        performance_impact: "minimal"
        
      - level: 2  
        strategy: "reduce_functionality"
        performance_impact: "moderate"
        
      - level: 3
        strategy: "basic_operation_only"
        performance_impact: "significant"
        
  circuit_breaker:
    # Circuit breaker pattern for failing servers
    failure_threshold: 5      # failures before opening circuit
    recovery_timeout: 30      # seconds before attempting recovery
    half_open_requests: 3     # test requests during recovery

# Performance Optimization
performance_optimization:
  caching:
    # Server response caching
    enable_response_caching: true
    cache_duration: 300       # seconds
    max_cache_size: 100      # responses
    cache_key_strategy: "operation_context_hash"
    
  request_optimization:
    # Request batching and optimization
    enable_request_batching: true
    batch_size: 3
    batch_timeout: 1000      # ms
    
  predictive_routing:
    # Predict optimal server based on patterns
    enable_prediction: true
    prediction_model: "pattern_based"
    prediction_confidence_threshold: 0.7

# Monitoring and Analytics
monitoring:
  metrics_collection:
    # Collect orchestration metrics
    collect_routing_decisions: true
    collect_performance_metrics: true  
    collect_error_patterns: true
    retention_days: 30
    
  analytics:
    # Server orchestration analytics
    routing_accuracy_tracking: true
    performance_trend_analysis: true
    optimization_recommendations: true
    
  alerts:
    # Alert thresholds
    high_error_rate: 0.1      # 10%
    slow_response_time: 5000  # ms
    server_unavailable: true